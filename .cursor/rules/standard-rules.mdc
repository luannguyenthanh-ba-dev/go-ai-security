---
alwaysApply: true
---
# Cursor Rules for Golang Project - DDD + Clean Architecture (NestJS Inspired)

## ğŸ¯ Architectural Overview
This project follows **Domain-Driven Design (DDD)** and **Clean Architecture**, inspired by **NestJS module philosophy**.
Each domain (e.g., `users`, `auth`, `orders`) is organized as an independent module under `/internal`.

The architecture layers are:
- **Domain** â†’ Pure business rules and entities.
- **UseCase (Application)** â†’ Business logic orchestration.
- **Repository (Infrastructure)** â†’ Data persistence (MongoDB, MySQL, Redis...).
- **Delivery (Interface)** â†’ API handlers (Gin), message consumers (RabbitMQ), etc.
- **DTOs** â†’ Define input/output models for Delivery layer.

---

## ğŸ§© Directory Structure Convention

/cmd/
main.go â†’ Application entrypoint
/config/ â†’ App configs (env, db connection, etc.)
/internal/
/<module>/
/domain/ â†’ Entities, value objects, domain errors, domain events
/usecase/ â†’ Application services and interfaces to domain
/repository/ â†’ Repository interfaces & implementations (e.g., MongoRepo)
/delivery/http/ â†’ Gin handlers, routes
/dto/ â†’ Request/Response structs
/pkg/ â†’ Shared utils (logger, middleware, config loader)

---

## ğŸ§  Coding Guidelines

1. **Never import across modules** directly.  
   Only communicate through **interfaces (contracts)**.

2. **Keep business rules pure**:  
   - Domain layer **must not import infrastructure packages**.  
   - No dependency on Gin, Mongo, Redis, etc. inside domain or usecase.

3. **Use dependency injection**:  
   Pass repositories/interfaces into usecase constructors.

4. **Each module = one bounded context**:  
   - Keep `/internal/users` independent from `/internal/auth`.  
   - Shared models go into `/pkg/shared` or `/pkg/types`.

5. **DTOs are not domain models**:  
   Use DTO for external input/output, and convert to domain entity in usecase.

6. **Error handling**:  
   - Define domain-specific errors in `/domain/errors.go`.  
   - Wrap infrastructure errors before returning them to usecase.

7. **Logging**:  
   Use a centralized logger from `/pkg/logger` â€” do not use `fmt.Println`.

8. **Configuration**:  
   Use `/pkg/config` to load `.env` or YAML configs once, then inject via constructor.

---

## âš™ï¸ Naming Conventions

- Packages use lowercase, singular (e.g., `user`, `auth`, `order`).
- Files follow responsibility naming:
  - `repository.go`, `usecase.go`, `handler.go`, `dto.go`, etc.
- Structs use PascalCase: `UserEntity`, `UserUseCase`, `UserRepository`.
- Interfaces are named by capability: `UserRepository`, `AuthService`.

---

## ğŸš€ Example Flow (Users Module)

1. `HTTP Handler` (Gin) â†’ receives request â†’ binds DTO.
2. Handler calls `UserUseCase.CreateUser(dto)`.
3. UseCase validates data, creates domain entity.
4. UseCase calls `UserRepository.Save(entity)`.
5. Repository persists data to MongoDB.
6. Response sent back via DTO.

---

## ğŸ” Example File Paths

/internal/users/domain/user_entity.go
/internal/users/usecase/user_usecase.go
/internal/users/repository/user_repository.go
/internal/users/delivery/http/user_handler.go
/internal/users/dto/user_dto.go
